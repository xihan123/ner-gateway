name: Build Release

on:
  push:
    tags:
    - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      draft:
        description: 'Create as draft'
        required: false
        type: boolean
        default: false
      pre_release:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  ONNX_RUNTIME_VERSION: "1.24.2"

jobs:
  build:
    name: Build on ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
        - target: x86_64-pc-windows-msvc
          runner: windows-latest
          artifact: ner-gateway-windows-x64.exe
          strip: true
        - target: aarch64-apple-darwin
          runner: macos-latest
          artifact: ner-gateway-macos-arm64
          strip: true
        - target: x86_64-unknown-linux-gnu
          runner: ubuntu-latest
          artifact: ner-gateway-linux-x64
          strip: true

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-registry-

    - name: Cache cargo index
      uses: actions/cache@v4
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-index-

    - name: Cache cargo build
      uses: actions/cache@v4
      with:
        path: backend/target
        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}-${{ matrix.target }}
        restore-keys: |
          ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}-
          ${{ runner.os }}-cargo-build-target-

    - name: Download ONNX Runtime (Windows)
      if: runner.os == 'Windows'
      run: |
        curl -LO https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNX_RUNTIME_VERSION }}/onnxruntime-win-x64-${{ env.ONNX_RUNTIME_VERSION }}.zip
        unzip onnxruntime-win-x64-${{ env.ONNX_RUNTIME_VERSION }}.zip
        mkdir -p onnx_libs
        cp onnxruntime-win-x64-${{ env.ONNX_RUNTIME_VERSION }}/lib/onnxruntime.dll onnx_libs/
        echo "ORT_LIB_PATH=$PWD/onnxruntime-win-x64-${{ env.ONNX_RUNTIME_VERSION }}/lib" >> $GITHUB_ENV
      shell: bash

    - name: Download ONNX Runtime (macOS ARM)
      if: matrix.target == 'aarch64-apple-darwin'
      run: |
        curl -LO https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNX_RUNTIME_VERSION }}/onnxruntime-osx-arm64-${{ env.ONNX_RUNTIME_VERSION }}.tgz
        tar -xzf onnxruntime-osx-arm64-${{ env.ONNX_RUNTIME_VERSION }}.tgz
        mkdir -p onnx_libs
        cp onnxruntime-osx-arm64-${{ env.ONNX_RUNTIME_VERSION }}/lib/libonnxruntime*.dylib onnx_libs/
        echo "ORT_LIB_PATH=$PWD/onnxruntime-osx-arm64-${{ env.ONNX_RUNTIME_VERSION }}/lib" >> $GITHUB_ENV
      shell: bash

    - name: Download ONNX Runtime (Linux)
      if: runner.os == 'Linux'
      run: |
        curl -LO https://github.com/microsoft/onnxruntime/releases/download/v${{ env.ONNX_RUNTIME_VERSION }}/onnxruntime-linux-x64-${{ env.ONNX_RUNTIME_VERSION }}.tgz
        tar -xzf onnxruntime-linux-x64-${{ env.ONNX_RUNTIME_VERSION }}.tgz
        mkdir -p onnx_libs
        cp onnxruntime-linux-x64-${{ env.ONNX_RUNTIME_VERSION }}/lib/libonnxruntime*.so* onnx_libs/
        echo "ORT_LIB_PATH=$PWD/onnxruntime-linux-x64-${{ env.ONNX_RUNTIME_VERSION }}/lib" >> $GITHUB_ENV
      shell: bash

    - name: Build release binary
      run: |
        cd backend
        cargo build --release --target ${{ matrix.target }}
      shell: bash

    - name: Strip symbols (Linux/macOS)
      if: matrix.strip && runner.os != 'Windows'
      run: |
        if [ "${{ runner.os }}" == "macOS" ]; then
          strip -x backend/target/${{ matrix.target }}/release/ner-gateway
        else
          strip -s backend/target/${{ matrix.target }}/release/ner-gateway
        fi
      shell: bash

    - name: Prepare artifact
      run: |
        mkdir -p artifacts

        if [ "${{ runner.os }}" == "Windows" ]; then
          cp "backend/target/${{ matrix.target }}/release/ner-gateway.exe" "artifacts/${{ matrix.artifact }}"
          cp onnx_libs/onnxruntime.dll artifacts/
        else
          cp backend/target/${{ matrix.target }}/release/ner-gateway artifacts/${{ matrix.artifact }}
          chmod +x artifacts/${{ matrix.artifact }}
          cp onnx_libs/libonnxruntime*.dylib artifacts/ 2>/dev/null || cp onnx_libs/libonnxruntime*.so* artifacts/ 2>/dev/null || true
        fi
      shell: bash

    - name: Backup uncompressed original
      run: |
        cp artifacts/${{ matrix.artifact }} artifacts/${{ matrix.artifact }}.uncompressed
      shell: bash

    - name: Compress with UPX (Windows)
      if: runner.os == 'Windows'
      uses: crazy-max/ghaction-upx@v3
      with:
        version: latest
        files: |
          artifacts/${{ matrix.artifact }}
        args: --best --lzma

    - name: Compress with UPX (Linux)
      if: runner.os == 'Linux'
      uses: crazy-max/ghaction-upx@v3
      with:
        version: latest
        files: |
          artifacts/${{ matrix.artifact }}
        args: --best --lzma

    - name: Create compressed copy and restore uncompressed
      if: runner.os != 'macOS'
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          artifact="${{ matrix.artifact }}"
          compressed_name="${artifact%.exe}-compressed.exe"
          mv "artifacts/${artifact}" "artifacts/${compressed_name}"
          echo "compressed_file=$compressed_name" >> $GITHUB_OUTPUT
        else
          mv artifacts/${{ matrix.artifact }} artifacts/${{ matrix.artifact }}.compressed
          echo "compressed_file=${{ matrix.artifact }}.compressed" >> $GITHUB_OUTPUT
        fi
        mv artifacts/${{ matrix.artifact }}.uncompressed artifacts/${{ matrix.artifact }}
      shell: bash
      id: compressed-name

    - name: Upload artifact (uncompressed)
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: artifacts/${{ matrix.artifact }}
        retention-days: 90

    - name: Upload artifact (compressed) - Windows
      if: runner.os == 'Windows'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}-compressed
        path: artifacts/${{ steps.compressed-name.outputs.compressed_file }}
        retention-days: 90

    - name: Upload artifact (compressed) - Linux
      if: runner.os == 'Linux'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}.compressed
        path: artifacts/${{ matrix.artifact }}.compressed
        retention-days: 90

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix=sha-

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to GitHub Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64,linux/arm64
        provenance: false
        sbom: false
        cache-from: |
          type=gha
          type=registry,ref=ghcr.io/${{ github.repository }}:buildcache
        cache-to: type=gha,mode=max

  release:
    name: Create GitHub Release
    needs: [ build, docker ]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        pattern: ner-gateway-*
        merge-multiple: true

    - name: Display structure of downloaded files
      run: ls -R artifacts
      shell: bash

    - name: Generate SHA256 checksums
      run: |
        cd artifacts
        find . -type f | sort | xargs sha256sum > SHA256SUMS.txt
        cat SHA256SUMS.txt
      shell: bash

    - name: Prepare release tag
      id: tag
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "tag=${{ inputs.version }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" == "push" ]; then
          echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" == "release" ]; then
          echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        else
          echo "tag=latest" >> $GITHUB_OUTPUT
        fi
      shell: bash

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.tag.outputs.tag }}
        name: NER Gateway ${{ steps.tag.outputs.tag }}
        draft: ${{ github.event_name == 'workflow_dispatch' && inputs.draft || false }}
        prerelease: ${{ github.event_name == 'workflow_dispatch' && inputs.pre_release || false }}
        generate_release_notes: true
        files: |
          artifacts/ner-gateway-*
          artifacts/SHA256SUMS.txt
        body: |
          ## NER Gateway ${{ steps.tag.outputs.tag }}

          基于 BERT 的中文姓名实体识别系统，使用 ONNX Runtime 进行高效推理。

          ### 下载

          | 平台 | 二进制文件 | 说明 |
          |------|------------|------|
          | Windows x64 | `ner-gateway-windows-x64.exe` + `onnxruntime.dll` | 未压缩版本 |
          | Windows x64 | `ner-gateway-windows-x64-compressed.exe` | UPX压缩版本，体积更小 |
          | macOS ARM64 | `ner-gateway-macos-arm64` + `libonnxruntime*.dylib` | Apple Silicon 原生支持 |
          | Linux x64 | `ner-gateway-linux-x64` + `libonnxruntime*.so` | |

          ### Docker 镜像

          ```bash
          docker pull ghcr.io/xihan123/ner-gateway:${{ steps.tag.outputs.tag }}
          ```

          ### UPX 压缩说明

          压缩版使用 UPX 压缩，体积减少 50-70%，可直接运行无需解压。

          ### 依赖说明

          每个平台的发布包包含：
          - 主程序二进制文件
          - ONNX Runtime 动态库（需要与主程序放在同一目录）

          ### 校验

          ```bash
          sha256sum -c SHA256SUMS.txt
          ```

          ### 快速开始

          **Windows:**
          ```powershell
          # 确保 onnxruntime.dll 与 ner-gateway.exe 在同一目录
          set NER_MODEL_PATH=./models/ner_model_int8.onnx
          set NER_VOCAB_PATH=./models/vocab.txt
          .\ner-gateway-windows-x64.exe
          ```

          **macOS/Linux:**
          ```bash
          # 确保 libonnxruntime.* 与 ner-gateway 在同一目录
          chmod +x ner-gateway-*
          NER_MODEL_PATH=./models/ner_model_int8.onnx NER_VOCAB_PATH=./models/vocab.txt ./ner-gateway-*
          ```

          ### Docker

          ```bash
          docker-compose up -d
          ```

          服务启动后访问 http://localhost:8080 打开审核界面。
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
